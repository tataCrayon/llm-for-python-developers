# 1 会话历史设计

首先，LangChain4j并不提供历史消息管理的功能。其目前只提供“记忆功能”。

> 不过我们使用 session_id 来管理 chatMemory。

## 1.1 映射关系

利用 token 解析出 userName，然后与 session_id 列表关联，再让 session_id 列表对应具体的历史对话。 生产中应当使用userId,
而不是userName。

## 1.2 会话生命周期管理

### 1.2.1 创建会话

采用隐式的方式，用户的体验可能会更好。
当前采取的是同DS一样的显示周期，点击创建新对话调用/session/create获取sessionId，开启新对话。

### 1.2.2 加载会话

用户关闭应用后再次打开，会从数据库加载历史记录，打开最近的**活跃**会话。

### 1.2.3 会话分支

预留有会话分支的设计，即parentId。但是DS和WQ都没做，那本项目也不做。

## 1.3 会话存储

因长对话比较常见，所以对话标识信息可以与对话内容分开存储。 对于非常长的对话，可以考虑分段存储或者定期归档。

### 1.3.1 会话结构

可以设计成结构化的或者半结构化的数据，都挺好存储的。

- 最近对话时间
- 创建时间
- 会话名称
- 会话ID
- 对话数据
    - 角色、消息  ```json  [    
      {"role": "user", "content": "你好，我想预订一张去台北的机票。"},    
      {"role": "assistant", "content": "没问题，请问您想在哪一天出发？"}  ]

```    
完整的消息示例：  ```json  
{  
    "sessionId": "uuid-1234-abcd",    "userId": "user-5678",    "sessionName": "关于台北机票的预订 (自动生成)", // 可选，由AI生成或用户命名  
    "createdAt": "2023-10-26T10:00:00Z",    "lastActiveAt": "2023-10-26T10:35:00Z",    "messages": [        {"role": "user", "content": "你好，我想预订一张去台北的机票。", "timestamp": "2023-10-26T10:00:00Z"},  
        {"role": "assistant", "content": "没问题，请问您想在哪一天出发？", "timestamp": "2023-10-26T10:01:00Z"}  
        // ... 更多消息  
    ]}  
```  

### 1.3.2 持久层

NoSQL和关系型数据库都行。


### 1.3.3 写消息并发

系统用户多时写压力是很大的，可使用队列处理。

## 1.4 多设备考虑

多设备会话互通。

# 2 模型上下文管理

需要考虑历史对话如何传递给大模型。
常见做法有：

- **滑动窗口（Sliding Window）**：只取对话历史的最后 N 条消息或最后 X 个 Token。
- **总结（Summarization）**：让另一个 LLM 模型对历史对话进行摘要，然后将摘要和最新对话一起传给主模型。
- **检索增强生成 (RAG)：** 将对话历史（甚至用户的其他数据）嵌入成向量，并利用向量数据库进行检索，将最相关的历史片段作为上下文输入给模型。这是目前处理长对话和复杂知识库的有效方案。



# 3 故障处理

至少有个错误上报。

# 4 优化设计

## 4.1 缓存

可以存储最近活跃对话、对话列表到缓存中。

## 4.2 分页加载

如果某个会话的历史消息非常多，加载时应考虑分页，而不是一次性加载所有消息。